<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="AUTHOR" CONTENT="pme@sources.redhat.com (Phil Edwards)">
   <META NAME="KEYWORDS" CONTENT="HOWTO, libstdc++, GCC, g++, libg++, STL">
   <META NAME="DESCRIPTION" CONTENT="HOWTO for the libstdc++ chapter 19.">
   <META NAME="GENERATOR" CONTENT="vi and eight fingers">
   <TITLE>libstdc++-v3 HOWTO:  Chapter 19</TITLE>
<LINK REL=StyleSheet HREF="../lib3styles.css">
<!-- $Id: howto.html,v 1.1 2000/12/10 04:04:54 pme Exp $ -->
</HEAD>
<BODY>

<H1 CLASS="centered"><A NAME="top">Chapter 19:  Diagnostics</A></H1>

<P>Chapter 19 deals with program diagnostics, such as exceptions
   and assertions.  You know, all the things we wish weren't even
   necessary at all.
</P>


<!-- ####################################################### -->
<HR>
<H1>Contents</H1>
<UL>
   <LI><A HREF="#1">Adding data to exceptions</A>
   <LI><A HREF="#2">Exception class hierarchy diagram</A>
   <LI><A HREF="#3">Concept checkers</A>
</UL>

<HR>

<!-- ####################################################### -->

<H2><A NAME="1">Adding data to exceptions</A></H2>
   <P>The standard exception classes carry with them a single string as
      data (usually describing what went wrong or where the 'throw' took
      place).  It's good to remember that you can add your own data to
      these exceptions when extending the heirarchy:
   </P>
   <PRE>
   using std::runtime_error;
   struct My_Exception : public runtime_error
   {
     public:
       My_Exception (const string&amp; whatarg)
           : runtime_error(whatarg), e(errno), id(GetDataBaseID()) { }
       int  errno_at_time_of_throw() const { return e; }
       DBID id_of_thing_that_threw() const { return id; }
     protected:
       int    e;
       DBID   id;     // some user-defined type
   };
   </PRE>
   <P>Return <A HREF="#top">to top of page</A> or
      <A HREF="../faq/index.html">to the FAQ</A>.
   </P>

<HR>
<H2><A NAME="2">Exception class hierarchy diagram</A></H2>
   <P>The <A HREF="exceptions_hiearchy.pdf">diagram</A> is in PDF, or
      at least it will be once it gets finished.
   </P>
   <P>Return <A HREF="#top">to top of page</A> or
      <A HREF="../faq/index.html">to the FAQ</A>.
   </P>

<HR>
<H2><A NAME="3">Concept checkers</A></H2>
   <P>First the good news, then the bad news.</P>
   <P><STRONG>Good news:</STRONG>  As part of their 3.3 release, SGI
      added some nifty macros which
      perform assertions on type properties.  For example, the Standard
      requires that types passed as template parameters to <TT>vector</TT>
      be &quot;Assignable&quot; (which means what you think it means).
   </P>
   <P>The concept checkers allow the source code for <TT>vector</TT> to
      declare
      <PRE>
   __STL_CLASS_REQUIRES(_Tp, _Assignable);
      </PRE>inside the template.  <TT>_Tp</TT> is the element type of the
      vector, and <TT>_Assignable</TT> is the concept to be checked (it is
      defined in some back-end header files).  When you instantiate
      <TT>vector&lt;MyType&gt;</TT>, compile-time checking can be done on
      whether MyType meets the requirements for vectors.
   </P>
   <P>Most (all?) of the containers and sequences are capable of performing
      concept checking during compilation, not just vector.
   </P>
   <P>If a concept is violated (thus causing a compilation failure), the
      error messages printed by the compiler will be of the form
      <PRE>
   _STL_ERROR::__<EM>foo</EM>_violation
      </PRE> where <EM>foo</EM> is a description of the precise violation.
      For example, if a type is required to support the preincrement
      operator but doesn't, then you will see
      _STL_ERROR::__postincrement_operator_requirement_violation, which
      should give you a hint as to the nature of the problem.
   </P>
   <P>Other names might be seen for more specific errors, for example,
      _ERROR_IN_STL_CONTAINER::__begin_iterator_accessor_requirement_violation.
   </P>
   <P>You will probably also see other errors as the malformed code is
      actually used.  The concept checking error messages should be printed
      before the others, so start at the top and work your way down.
   </P>
   <P><STRONG>Bad news:</STRONG>  The current checking code is somewhat
      messy.  It results in no runtime overhead, but there is a space
      penalty (sometimes a very large one) in the generated code.  And the
      code itself has bugs.
   </P>
   <P>Concept checking can be disabled when you build your code.  Just
      define (via -D or #define) the macro
      <TT>_STL_NO_CONCEPT_CHECKS</TT> (yes, with the leading underscore).
      In fact, this may already be defined in the library by default,
      depending on what decision we come to.
   </P>
   <P><STRONG>More good news:</STRONG>  Replacement code has already been
      written by the same author of the original code.  It's available at
      Boost and we hope to integrate it into the library.
   <P>Return <A HREF="#top">to top of page</A> or
      <A HREF="../faq/index.html">to the FAQ</A>.
   </P>


<!-- ####################################################### -->

<HR>
<P CLASS="fineprint"><EM>
Comments and suggestions are welcome, and may be sent to
<A HREF="mailto:pme@sources.redhat.com">Phil Edwards</A> or
<A HREF="mailto:gdr@gcc.gnu.org">Gabriel Dos Reis</A>.
<BR> $Id: howto.html,v 1.1 2000/12/10 04:04:54 pme Exp $
</EM></P>


</BODY>
</HTML>
